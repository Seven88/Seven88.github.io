<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[《Web 全栈工程师的自我修养》思维导图]]></title>
      <url>https://seven88.github.io/2016/06/10/%E3%80%8AWeb-%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p><img src="/images/webfullstackmindnoe.png" alt="《Web 全栈工程师的自我修养》思维导图"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【译】简单 12 步理解 Python 装饰器]]></title>
      <url>https://seven88.github.io/2016/05/10/%E3%80%90%E8%AF%91%E3%80%91%E7%AE%80%E5%8D%95-12-%E6%AD%A5%E7%90%86%E8%A7%A3-Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      <content type="html"><![CDATA[<p><strong>英文出处：<a href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/" target="_blank" rel="external">Simeon Franklin</a></strong><br><strong>校稿：<a href="http://www.jobbole.com/members/hanxiaomax" target="_blank" rel="external">伯乐在线 - 艾凌风</a></strong></p>
<p>好吧，我标题党了。作为 Python 教师，我发现理解装饰器是学生们从接触后就一直纠结的问题。那是因为装饰器确实难以理解！想弄明白装饰器，需要理解一些函数式编程概念，并且要对Python中函数定义和函数调用语法中的特性有所了解。使用装饰器非常简单（见步骤10），但是写装饰器却很复杂。</p>
<p>虽然我没法让装饰器变得简单，但也许通过将问题进行一步步的讲解，可以帮助你更容易理解装饰器。由于装饰器较为复杂，文章会比较长，请坚持住！我会尽量使每个步骤简单明了，这样如果你理解了各个步骤，就能理解装饰器的原理。本文假定你具备最基础的 Python 知识，另外本文对工作中大量使用 Python 的人将大有帮助。</p>
<p>此外需要说明的是，本文中 Python 代码示例是用 <code>doctest</code> 模块来执行的。代码看起来像是交互式 Python 控制台会话（<code>&gt;&gt;&gt;</code> 和 <code>…</code> 表示 Python 语句，输出则另起一行）。偶然有以“doctest”开头的“奇怪”注释——那些只是 <code>doctest</code> 的指令，可以忽略。</p>
<a id="more"></a>
<h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h3><p>在 Python 中，使用关键字 <code>def</code> 和一个函数名以及一个可选的参数列表来定义函数。函数使用 <code>return</code> 关键字来返回值。定义和使用一个最简单的函数例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>函数体（和 Python 中所有的多行语句一样）由强制性的缩进表示。在函数名后面加上括号就可以调用函数。</p>
<h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h3><p>在 Python 函数中会创建一个新的作用域。Python 高手也称函数有自己的命名空间。也就是说，当在函数体中遇到变量时，Python 会首先在该函数的命名空间中寻找变量名。Python 有几个函数用来查看命名空间。下面来写一个简单函数来看看局部变量和全局变量的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a_string = <span class="string">"This is a global variable"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> locals()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> globals() <span class="comment"># doctest: +ELLIPSIS</span></div><div class="line">&#123;..., <span class="string">'a_string'</span>: <span class="string">'This is a global variable'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo() <span class="comment"># 2</span></div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<p>内建函数 <code>globals</code> 返回一个包含所有 Python 能识别变量的字典。（为了更清楚的描述，输出时省略了 Python 自动创建的变量。）在注释 <code>#2</code> 处，调用了 <code>foo</code> 函数，在函数中打印局部变量的内容。从中可以看到，函数 <code>foo</code> 有自己单独的、此时为空的命名空间。</p>
<h3 id="3-变量解析规则"><a href="#3-变量解析规则" class="headerlink" title="3. 变量解析规则"></a>3. 变量解析规则</h3><p>当然，以上并不意味着我们不能在函数内部使用全局变量。Python 的作用域规则是， 变量的创建总是会创建一个新的局部变量但是变量的访问（包括修改）在局部作用域查找然后是整个外层作用域来寻找匹配。所以如果修改 <code>foo</code> 函数来打印全部变量，结果将是我们希望的那样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a_string = <span class="string">"This is a global variable"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> a_string <span class="comment"># 1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</div><div class="line">This <span class="keyword">is</span> a <span class="keyword">global</span> variable</div></pre></td></tr></table></figure>
<p>在 <code>#1</code> 处，Python 在函数 <code>foo</code> 中搜索局部变量 <code>a_string</code>，但是没有找到，然后继续搜索同名的全局变量。</p>
<p>另一方面，如果尝试在函数里给全局变量赋值，结果并不是我们想要的那样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a_string = <span class="string">"This is a global variable"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    a_string = <span class="string">"test"</span> <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> locals()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</div><div class="line">&#123;<span class="string">'a_string'</span>: <span class="string">'test'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a_string <span class="comment"># 2</span></div><div class="line"><span class="string">'This is a global variable'</span></div></pre></td></tr></table></figure>
<p>从上面代码可见，全部变量可以被访问（如果是可变类型，甚至可以被修改）但是（默认）不能被赋值。在函数 <code>#1</code> 处，实际上是创建了一个和全局变量相同名字的局部变量，并且“覆盖”了全局变量。通过在函数 <code>foo</code> 中打印局部命名空间可以印证这一点，并且发现局部命名空间有了一项数据。在 <code>#2</code> 处的输出可以看到，全局命名空间里变量 <code>a_string</code> 的值并没有改变。</p>
<h3 id="4-变量生命周期"><a href="#4-变量生命周期" class="headerlink" title="4. 变量生命周期"></a>4. 变量生命周期</h3><p>值得注意的是，变量不仅是在命名空间中有效，它们也有生命周期。思考下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    x = <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> x <span class="comment"># 1</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">NameError: name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</div></pre></td></tr></table></figure>
<p>这个问题不仅仅是因为 <code>#1</code> 处的作用域规则（虽然那是导致 <code>NameError</code> 的原因），也与 Python 和很多其他语言中函数调用的实现有关。没有任何语法可以在该处取得变量 <code>x</code> 的值——它确确实实不存在！函数 <code>foo</code> 的命名空间在每次函数被调用时重新创建，在函数结束时销毁。</p>
<h3 id="5-函数的实参和形参"><a href="#5-函数的实参和形参" class="headerlink" title="5. 函数的实参和形参"></a>5. 函数的实参和形参</h3><p>Python 允许向函数传递参数。形参名在函数里为局部变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> locals()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>)</div><div class="line">&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>Python 有一些不同的方法来定义和传递函数参数。想要深入的了解，请参考 <a href="http://docs.python.org/tutorial/controlflow.html#more-on-defining-functions" target="_blank" rel="external">Python 文档关于函数的定义</a>。来说一个简单版本：函数参数可以是强制的位置参数或者可选的有默认值的关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x, y=<span class="number">0</span>)</span>:</span> <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x - y</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">3</span>, <span class="number">1</span>) <span class="comment"># 2</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">3</span>) <span class="comment"># 3</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo() <span class="comment"># 4</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">TypeError: foo() takes at least <span class="number">1</span> argument (<span class="number">0</span> given)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo(y=<span class="number">1</span>, x=<span class="number">3</span>) <span class="comment"># 5</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>在 <code>#1</code> 处，定义了有一个位置参数 <code>x</code> 和一个关键字参数 <code>y</code>的函数。接着可以看到，在 <code>#2</code> 处通过普通传参的方式调用该函数——实参值按位置传递给了 <code>foo</code> 的参数，尽管其中一个参数是作为关键字参数定义的。在 <code>#3</code> 处可以看到，调用函数时可以无需给关键字参数传递实参——如果没有给关键字参数 <code>y</code> 传值，Python 将使用声明的默认值 0 为其赋值。当然，参数 <code>x</code> （即位置参数）的值不能为空——在 <code>#4</code> 示范了这种错误异常。</p>
<p>都很清楚简单，对吧？接下来有些复杂了—— Python 支持在函数调用时使用关键字实参。看 <code>#5</code> 处，虽然函数是用一个关键字形参和一个位置形参定义的，但此处使用了两个关键字实参来调用该函数。因为参数都有名称，所以传递参数的顺序没有影响。</p>
<p>反过来也是对的。函数 <code>foo</code> 的一个参数被定义为关键字参数，但是如果按位置顺序传递一个实参——在 <code>#2</code> 处调用 <code>foo(3, 1)</code>，给位置形参 <code>x</code> 传实参 3 并给第二个形参 <code>y</code> 传第二个实参（整数 1），尽管 <code>y</code> 被定义为关键字参数。</p>
<p>哇哦！说了这么多看起来可以简单概括为一点：函数的参数可以有名称或位置。也就是说这其中稍许的不同取决于是函数定义还是函数调用。可以对用位置形参定义的函数传递关键字实参，反过来也可行！如果还想进一步了解请查看 <a href="http://docs.python.org/tutorial/controlflow.html#more-on-defining-functions" target="_blank" rel="external">Python 文档</a>。</p>
<h3 id="6-内嵌函数"><a href="#6-内嵌函数" class="headerlink" title="6. 内嵌函数"></a>6. 内嵌函数</h3><p>Python 允许创建内嵌函数。即可以在函数内部声明函数，并且所有的作用域和生命周期规则仍然适用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    x = <span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">print</span> x <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>    inner() <span class="comment"># 2</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>outer()</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>以上代码看起来有些复杂，但它仍是易于理解的。来看 <code>#1</code> —— Python 搜索局部变量 <code>x</code> 失败，然后在属于另一个函数的外层作用域里寻找。变量 <code>x</code> 是函数 <code>outer</code> 的局部变量，但函数 <code>inner</code> 仍然有外层作用域的访问权限（至少有读和修改的权限）。在 <code>#2</code> 处调用函数 <code>inner</code>。值得注意的是，<code>inner</code> 在此处也只是一个变量名，遵循 Python 的变量查找规则——Python 首先在 <code>outer</code> 的作用域查找并找到了局部变量 <code>inner</code>。</p>
<h3 id="7-函数是-Python-中的一级对象"><a href="#7-函数是-Python-中的一级对象" class="headerlink" title="7. 函数是 Python 中的一级对象"></a>7. 函数是 Python 中的一级对象</h3><p>在 Python 中有个常识：函数和其他任何东西一样，都是对象。函数包含变量，它并不那么特殊。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(int, object) <span class="comment"># all objects in Python inherit from a common baseclass</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__ <span class="comment"># 1</span></div><div class="line">&lt;type <span class="string">'function'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(foo.__class__, object)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>也许你从未考虑过函数可以有属性——但是函数在 Python 中，和其他任何东西一样都是对象。（如果对此感觉困惑，稍后你会看到 Python 中的类也是对象，和其他任何东西一样！）也许这有点学术的感觉——在 Python 中函数只是常规的值，就像其他任意类型的值一样。这意味着可以将函数当做实参传递给函数，或者在函数中将函数作为返回值返回。如果你从未想过这样使用，请看下面的可执行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x - y</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(func, x, y)</span>:</span> <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> func(x, y) <span class="comment"># 2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>apply(add, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># 3</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>apply(sub, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>这个示例对你来说应该不陌生——<code>add</code> 和 <code>sub</code> 是标准的 Python 函数，都是接受两个值并返回一个计算的值。在 <code>#1</code> 处可以看到变量接收一个就像其他普通变量一样的函数。在 <code>#2</code> 处调用了传递给 <code>apply</code> 的函数 <code>fun</code>——在 Python 中双括号是调用操作符，调用变量名包含的值。在 <code>#3</code> 处展示了在 Python 中把函数作为值传参并没有特别的语法——和其他变量一样，函数名就是变量标签。</p>
<p>也许你之前见过这种写法—— Python 使用函数作为实参，常见的操作如：通过传递一个函数给 <code>key</code> 参数，来自定义使用内建函数 <code>sorted</code>。但是，将函数作为值返回会怎样？思考下面代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">"Inside inner"</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner <span class="comment"># 1</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = outer() <span class="comment">#2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo <span class="comment"># doctest:+ELLIPSIS</span></div><div class="line">&lt;function inner at <span class="number">0</span>x...&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</div><div class="line">Inside inner</div></pre></td></tr></table></figure>
<p>这看起来也许有点怪异。在 <code>#1</code> 处返回一个其实是函数标签的变量 <code>inner</code>。也没有什么特殊语法——函数 <code>outer</code> 返回了并没有被调用的函数 <code>inner</code>。还记得变量的生命周期吗？每次调用函数 <code>outer</code> 的时候，函数 <code>inner</code> 会被重新定义，但是如果函数 <code>ouer</code> 没有返回 <code>inner</code>，当 <code>inner</code> 超出 <code>outer</code> 的作用域，<code>inner</code> 的生命周期将结束。</p>
<p>在 <code>#2</code> 处将获得返回值即函数 <code>inner</code>，并赋值给新变量 <code>foo</code>。可以看到如果鉴定 <code>foo</code>，它确实包含函数 <code>inner</code>，通过使用调用操作符（双括号，还记得吗？）来调用它。虽然看起来可能有点怪异，但是目前为止并没有什么很难理解的，对吧？hold 住，因为接下来会更怪异！</p>
<h3 id="8-闭包"><a href="#8-闭包" class="headerlink" title="8. 闭包"></a>8. 闭包</h3><p>先不着急看闭包的定义，让我们从一段示例代码开始。如果将上一个示例稍微修改下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    x = <span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">print</span> x <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = outer()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.func_closure <span class="comment"># doctest: +ELLIPSIS</span></div><div class="line">(&lt;cell at <span class="number">0</span>x...: int object at <span class="number">0</span>x...&gt;,)</div></pre></td></tr></table></figure>
<p>从上一个示例可以看到，<code>inner</code> 是 <code>outer</code> 返回的一个函数，存储在变量 <code>foo</code> 里然后用 <code>foo()</code> 来调用。但是它能运行吗？先来思考一下作用域规则。</p>
<p>Python 中一切都按作用域规则运行—— <code>x</code> 是函数 <code>outer</code> 中的一个局部变量，当函数 <code>inner</code> 在 <code>#1</code> 处打印 <code>x</code> 时，Python 在 <code>inner</code> 中搜索局部变量但是没有找到，然后在外层作用域即函数 <code>outer</code> 中搜索找到了变量 <code>x</code>。</p>
<p>但如果从变量的生命周期角度来看应该如何呢？变量 <code>x</code> 对函数 <code>outer</code> 来说是局部变量，即只有当 <code>outer</code> 运行时它才存在。只有当 <code>outer</code> 返回后才能调用 <code>inner</code>，所以依据 Python 运行机制，在调用 <code>inner</code> 时 <code>x</code> 就应该不存在了，那么这里应该有某种运行错误出现。</p>
<p>结果并不是如此，返回的 <code>inner</code> 函数正常运行。Python 支持一种名为函数闭包的特性，意味着 在非全局作用域定义的 <code>inner</code> 函数在定义时记得外层命名空间是怎样的。<code>inner</code> 函数包含了外层作用域变量，通过查看它的 <code>func_closure</code> 属性可以看出这种函数闭包特性。</p>
<p>记住——每次调用函数 <code>outer</code> 时，函数 <code>inner</code> 都会被重新定义。此时 <code>x</code> 的值没有变化，所以返回的每个 <code>inner</code> 函数和其它的 <code>inner</code> 函数运行结果相同，但是如果稍做一点修改呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">print</span> x <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print1 = outer(<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print2 = outer(<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print1()</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print2()</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>从这个示例可以看到闭包——函数记住其外层作用域的事实——可以用来构建本质上有一个硬编码参数的自定义函数。虽然没有直接给 <code>inner</code> 函数传参 1 或 2，但构建了能“记住”该打印什么数的 <code>inner</code> 函数自定义版本。</p>
<p>闭包是强大的技术——在某些方面来看可能感觉它有点像面向对象技术：<code>outer</code> 作为 <code>inner</code> 的构造函数，有一个类似私有变量的 <code>x</code>。闭包的作用不胜枚举——如果你熟悉 Python中 <code>sorted</code> 函数的参数 <code>key</code>，也许你已经写过 <code>lambda</code> 函数通过第二项而非第一项来排序一些列表。也可以写一个 <code>itemgetter</code> 函数，接收一个用于检索的索引并返回一个函数，然后就能恰当的传递给 <code>key</code> 参数了。</p>
<p>但是这么用闭包太没意思了！让我们再次从头开始，写一个装饰器。</p>
<h3 id="9-装饰器"><a href="#9-装饰器" class="headerlink" title="9. 装饰器"></a>9. 装饰器</h3><p>装饰器其实就是一个有函数作为参数并返回一个替换函数的可执行函数。让我们从简单的开始，直到能写出实用的装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(some_func)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">"before some_func"</span></div><div class="line"><span class="meta">... </span>        ret = some_func() <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> ret + <span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>decorated = outer(foo) <span class="comment"># 2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>decorated()</div><div class="line">before some_func</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>请仔细看这个装饰器示例。首先，定义了一个带单个参数 <code>some_func</code> 的名为 <code>outer</code> 的函数。然后在 <code>outer</code> 内部定义了一个内嵌函数 <code>inner</code>。<code>inner</code> 函数将打印一行字符串然后调用 <code>some_func</code>，并在 <code>#1</code> 处获取其返回值。在每次 <code>outer</code> 被调用时，<code>some_func</code> 的值可能都会不同，但不论 <code>some_func</code> 是什么函数，都将调用它。最后，<code>inner</code> 返回 <code>some_func()</code> 的返回值加 1。在 <code>#2</code> 处可以看到，当调用赋值给 <code>decorated</code> 的返回函数时，得到的是一行文本输出和返回值 2，而非期望的调用 <code>foo</code> 的返回值 1。</p>
<p>我们可以说变量 <code>decorated</code> 是 <code>foo</code> 的装饰版——即 <code>foo</code> 加上一些东西。事实上，如果写了一个实用的装饰器，可能会想用装饰版来代替 <code>foo</code>，这样就总能得到“附带其他东西”的 <code>foo</code> 版本。用不着学习任何新的语法，通过将包含函数的变量重新赋值就能轻松做到这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = outer(foo)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo <span class="comment"># doctest: +ELLIPSIS</span></div><div class="line">&lt;function inner at <span class="number">0</span>x...&gt;</div></pre></td></tr></table></figure>
<p>现在任意调用 <code>foo()</code> 都不会得到原来的 <code>foo</code>，而是新的装饰器版！明白了吗？来写一个更实用的装饰器。</p>
<p>想象一个提供坐标对象的库。它们可能主要由一对对的 <code>x</code>、<code>y</code>坐标组成。遗憾的是坐标对象不支持数学运算，并且我们也无法修改源码。然而我们需要做很多数学运算，所以要构造能够接收两个坐标对象的 <code>add</code> 和 <code>sub</code> 函数，并且做适当的数学运算。这些函数很容易实现（为方便演示，提供一个简单的 <code>Coordinate</code> 类）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></div><div class="line"><span class="meta">... </span>        self.x = x</div><div class="line"><span class="meta">... </span>        self.y = y</div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"Coord: "</span> + str(self.__dict__)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> Coordinate(a.x + b.x, a.y + b.y)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(a, b)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> Coordinate(a.x - b.x, a.y - b.y)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>one = Coordinate(<span class="number">100</span>, <span class="number">200</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>two = Coordinate(<span class="number">300</span>, <span class="number">200</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add(one, two)</div><div class="line">Coord: &#123;<span class="string">'y'</span>: <span class="number">400</span>, <span class="string">'x'</span>: <span class="number">400</span>&#125;</div></pre></td></tr></table></figure>
<p>但是如果 <code>add</code> 和 <code>sub</code> 函数必须有边界检测功能呢？也许只能对正坐标进行加或减，并且返回值也限制为正坐标。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>one = Coordinate(<span class="number">100</span>, <span class="number">200</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>two = Coordinate(<span class="number">300</span>, <span class="number">200</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>three = Coordinate(<span class="number">-100</span>, <span class="number">-100</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sub(one, two)</div><div class="line">Coord: &#123;<span class="string">'y'</span>: <span class="number">0</span>, <span class="string">'x'</span>: <span class="number">-200</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add(one, three)</div><div class="line">Coord: &#123;<span class="string">'y'</span>: <span class="number">100</span>, <span class="string">'x'</span>: <span class="number">0</span>&#125;</div></pre></td></tr></table></figure>
<p>但我们希望在不修改 <code>one</code>、<code>two</code> 和 <code>three</code>的基础上，<code>one</code> 和 <code>two</code> 的差值为 <code>{x: 0, y: 0}</code>，<code>one</code> 和 <code>three</code> 的和为 <code>{x: 100, y: 200}</code>。接下来用一个边界检测装饰器来实现这一点，而不用对每个函数里的输入参数和返回值添加边界检测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">checker</span><span class="params">(a, b)</span>:</span> <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">if</span> a.x &lt; <span class="number">0</span> <span class="keyword">or</span> a.y &lt; <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            a = Coordinate(a.x <span class="keyword">if</span> a.x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>, a.y <span class="keyword">if</span> a.y &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</div><div class="line"><span class="meta">... </span>        <span class="keyword">if</span> b.x &lt; <span class="number">0</span> <span class="keyword">or</span> b.y &lt; <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            b = Coordinate(b.x <span class="keyword">if</span> b.x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>, b.y <span class="keyword">if</span> b.y &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</div><div class="line"><span class="meta">... </span>        ret = func(a, b)</div><div class="line"><span class="meta">... </span>        <span class="keyword">if</span> ret.x &lt; <span class="number">0</span> <span class="keyword">or</span> ret.y &lt; <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            ret = Coordinate(ret.x <span class="keyword">if</span> ret.x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>, ret.y <span class="keyword">if</span> ret.y &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> ret</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> checker</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add = wrapper(add)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sub = wrapper(sub)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sub(one, two)</div><div class="line">Coord: &#123;<span class="string">'y'</span>: <span class="number">0</span>, <span class="string">'x'</span>: <span class="number">0</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add(one, three)</div><div class="line">Coord: &#123;<span class="string">'y'</span>: <span class="number">200</span>, <span class="string">'x'</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure>
<p>装饰器和之前一样正常运行——返回了一个修改版函数，但在这次示例中通过检测和修正输入参数和返回值，将任何负值的 <code>x</code> 或 <code>y</code> 用 <code>0</code> 来代替，实现了上面的需求。</p>
<p>是否这么做是见仁见智的，它让代码更加简洁：通过将边界检测从函数本身分离，使用装饰器包装它们，并应用到所有需要的函数。可替换的方案是：在每个数学运算函数返回前，对每个输入参数和输出结果调用一个函数，不可否认，就对函数应用边界检测的代码量而言，使用装饰器至少是较少重复的。事实上，如果要装饰的函数是我们自己实现的，可以使装饰器应用得更明确一点。</p>
<h3 id="10-函数装饰器-符号的应用"><a href="#10-函数装饰器-符号的应用" class="headerlink" title="10. 函数装饰器 @ 符号的应用"></a>10. 函数装饰器 @ 符号的应用</h3><p>Python 2.4 通过在函数定义前添加一个装饰器名和 @ 符号，来实现对函数的包装。在上面代码示例中，用了一个包装的函数来替换包含函数的变量来实现了装饰函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>add = wrapper(add)</div></pre></td></tr></table></figure>
<p>这种模式可以随时用来包装任意函数。但是如果定义了一个函数，可以用 @ 符号来装饰函数，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>@wrapper</div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> Coordinate(a.x + b.x, a.y + b.y)</div></pre></td></tr></table></figure>
<p>值得注意的是，这种方式和简单的使用 <code>wrapper</code> 函数的返回值来替换原始变量的做法没有什么不同—— Python 只是添加了一些语法糖来使之看起来更加明确。</p>
<p>使用装饰器很简单！虽说写类似 <code>staticmethod</code> 或者 <code>classmethod</code> 的实用装饰器比较难，但用起来仅仅需要在函数前添加 <code>@装饰器名</code> 即可！</p>
<h3 id="11-args-和-kwargs"><a href="#11-args-和-kwargs" class="headerlink" title="11. args 和 *kwargs"></a>11. <em>args 和 *</em>kwargs</h3><p>上面我们写了一个实用的装饰器，但它是硬编码的，只适用于特定类型的函数——带有两个参数的函数。内部函数 <code>checker</code> 接收两个参数，然后继续将参数传给闭包中的函数。如果我们想要一个能适用任何函数的装饰器呢？让我们来实现一个为每次被装饰函数的调用添加一个计数器的装饰器，但不改变被装饰函数。这意味着这个装饰器必须接收它所装饰的任何函数的调用信息，并且在调用这些函数时将传递给该装饰器的任何参数都传递给它们。</p>
<p>碰巧，Python 对这种特性提供了语法支持。请务必阅读 <a href="http://docs.python.org/tutorial/controlflow.html#arbitrary-argument-lists" target="_blank" rel="external">Python Tutorial</a> 以了解更多，但在定义函数时使用 <code>*</code> 的用法意味着任何传递给函数的额外位置参数都是以 <code>*</code> 开头的。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">one</span><span class="params">(*args)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> args <span class="comment"># 1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>one()</div><div class="line">()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>one(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">two</span><span class="params">(x, y, *args)</span>:</span> <span class="comment"># 2</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> x, y, args</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>two(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</div><div class="line">a b (<span class="string">'c'</span>,)</div></pre></td></tr></table></figure>
<p>第一个函数 <code>one</code> 简单的打印了传给它的任何位置参数（如果有）。在 <code>#1</code> 处可以看到，在函数内部只是简单的用到了变量 <code>args</code> —— <code>*args</code> 只在定义函数时用来表示位置参数将会保存在变量 <code>args</code> 中。Python 也允许指定一些变量，并捕获任何在 <code>args</code> 里的额外参数，如 <code>#2</code> 处所示。</p>
<p><code>*</code> 符号也可以用在函数调用时，在这里它也有类似的意义。在调用函数时，以 <code>*</code> 开头的变量表示该变量内容需被取出用做位置参数。再举例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add(lst[<span class="number">0</span>], lst[<span class="number">1</span>]) <span class="comment"># 1</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add(*lst) <span class="comment"># 2</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>在 #1 处的代码和 #2 处的作用相同——可以手动做的事情，在 #2 处 Python 帮我们自动处理了。这看起来不错，<code>*args</code> 可以表示在调用函数时从迭代器中取出位置参数， 也可以表示在定义函数时接收额外的位置参数。</p>
<p>接下来介绍稍微复杂一点的用来表示字典和键值对的 <code>**</code>，就像 <code>*</code> 用来表示迭代器和位置参数。很简单吧？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(**kwargs)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> kwargs</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</div><div class="line">&#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo(x=<span class="number">1</span>, y=<span class="number">2</span>)</div><div class="line">&#123;<span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'x'</span>: <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>当定义一个函数时，使用 <code>**kwargs</code> 来表示所有未捕获的关键字参数将会被存储在字典 <code>kwargs</code> 中。此前 <code>args</code> 和 <code>kwargs</code> 都不是 Python 中语法的一部分，但在函数定义时使用这两个变量名是一种惯例。和 <code>*</code> 的使用一样，可以在函数调用和定义时使用 <code>**</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dct = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bar(**dct)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<h3 id="12-更通用的装饰器"><a href="#12-更通用的装饰器" class="headerlink" title="12. 更通用的装饰器"></a>12. 更通用的装饰器</h3><p>用学到的新知识，可以写一个记录函数参数的装饰器。为简单起见，仅打印到标准输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment">#1</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">"Arguments were: %s, %s"</span> % (args, kwargs)</div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs) <span class="comment">#2</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner</div></pre></td></tr></table></figure>
<p>注意在 <code>#1</code> 处函数 <code>inner</code> 接收任意数量和任意类型的参数，然后在 <code>#2</code> 处将他们传递给被包装的函数。这样一来我们可以包装或装饰任意函数，而不用管它的签名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>@logger</div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(x, y=<span class="number">1</span>)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * y</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>@logger</div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">foo2</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo1(<span class="number">5</span>, <span class="number">4</span>)</div><div class="line">Arguments were: (<span class="number">5</span>, <span class="number">4</span>), &#123;&#125;</div><div class="line"><span class="number">20</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo1(<span class="number">1</span>)</div><div class="line">Arguments were: (<span class="number">1</span>,), &#123;&#125;</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo2()</div><div class="line">Arguments were: (), &#123;&#125;</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>每一个函数的调用会有一行日志输出和预期的返回值。</p>
<h3 id="再聊装饰器"><a href="#再聊装饰器" class="headerlink" title="再聊装饰器"></a>再聊装饰器</h3><p>如果你一直看到了最后一个实例，祝贺你，你已经理解了装饰器！你可以用新掌握的知识做更多的事了。</p>
<p>你也许考虑需要进一步的学习：<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808" target="_blank" rel="external">Bruce Eckel 有一篇很赞的关于装饰器文章</a>，他使用了对象而非函数来实现了装饰器。你会发现 OOP 代码比纯函数版的可读性更好。Bruce 还有一篇后续文章 <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240845" target="_blank" rel="external">providing arguments to decorators</a>，用对象实现装饰器也许比用函数实现更简单。最后，你可以去研究一下内建包装函数 <a href="http://docs.python.org/dev/library/functools.html" target="_blank" rel="external">functools</a>，它是一个在装饰器中用来修改替换函数签名的装饰器，使得这些函数更像是被装饰的函数。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gulp 简介及入门]]></title>
      <url>https://seven88.github.io/2016/01/12/Gulp-%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h3 id="什么是-Gulp？"><a href="#什么是-Gulp？" class="headerlink" title="什么是 Gulp？"></a>什么是 Gulp？</h3><p>Gulp 是一款强大的基于 Node.js 的前端构建工具。</p>
<h3 id="什么是前端构建？"><a href="#什么是前端构建？" class="headerlink" title="什么是前端构建？"></a>什么是前端构建？</h3><blockquote>
<p>一句话：自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。(引用自：<a href="http://www.gruntjs.net/" target="_blank" rel="external">Grunt 官网</a>)</p>
</blockquote>
<h3 id="同类工具-Grunt-对比"><a href="#同类工具-Grunt-对比" class="headerlink" title="同类工具 Grunt 对比"></a>同类工具 Grunt 对比</h3><ul>
<li>出道晚，人气更旺。<br> 目前 <a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">Gulp 19k+ stars</a>，<a href="https://github.com/gruntjs/grunt" target="_blank" rel="external">Grunt 10k+ stars</a> on GitHub。</li>
<li>比简单更简单。<br> Gulp 遵循代码优于配置策略，Grunt 的配置通常让人眼花缭乱;<br> Gulp 只有5个核心 API；<br> Gulp 的插件更纯粹，单一的功能，坚持一个插件只做一件事。</li>
<li>核心设计基于Unix流的概念，通过管道连接，不需要写中间文件。</li>
</ul>
<h3 id="安装-Gulp"><a href="#安装-Gulp" class="headerlink" title="安装 Gulp"></a>安装 Gulp</h3><p><strong>安装 Node.js</strong>：<br>前往 <a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/</a>，Download，Install，Done！<br>npm (Node Package Manager) 会随着 Node.js 一起安装。</p>
<p><strong>全局安装 Gulp：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install gulp -g</div></pre></td></tr></table></figure>
<p><strong>项目根目录安装</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install gulp --save-dev --registry=https://registry.npm.taobao.org/</div><div class="line">// 使用 --save-dev 会将 gulp 自动添加到 package.json 的 devDependencies</div><div class="line">// 使用淘宝源</div></pre></td></tr></table></figure>
<p>(<em>package.json 是什么？<a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></em>)</p>
<a id="more"></a>
<h3 id="安装Gulp插件"><a href="#安装Gulp插件" class="headerlink" title="安装Gulp插件"></a>安装Gulp插件</h3><p><strong>常用插件：</strong><br>sass的编译（<a href="https://github.com/sindresorhus/gulp-ruby-sass" target="_blank" rel="external">gulp-ruby-sass</a>）<br>压缩css（<a href="https://github.com/jonathanepollack/gulp-minify-css" target="_blank" rel="external">gulp-minify-css</a>）<br>压缩js代码（<a href="https://github.com/terinjokes/gulp-uglify" target="_blank" rel="external">gulp-uglify</a>）<br>压缩图片（<a href="https://github.com/sindresorhus/gulp-imagemin" target="_blank" rel="external">gulp-imagemin</a>）<br>图片缓存，只有图片替换了才压缩（<a href="https://github.com/jgable/gulp-cache" target="_blank" rel="external">gulp-cache</a>）<br>清除文件（<a href="https://www.npmjs.org/package/del" target="_blank" rel="external">del</a>）<br>编译html模板（<a href="https://github.com/zont/gulp-usemin" target="_blank" rel="external">gulp-usemin</a>）<br>顺序执行任务（<a href="https://github.com/OverZealous/run-sequence" target="_blank" rel="external">run-sequence</a>）<br>自动刷新页面（<a href="https://github.com/vohof/gulp-livereload" target="_blank" rel="external">gulp-livereload</a>）需浏览器插件配合使用: <a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" target="_blank" rel="external">Chrome插件下载</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 单个安装</div><div class="line">npm install gulp-uglify --save-dev</div><div class="line">// 批量安装</div><div class="line">npm install gulp-ruby-sass gulp-minify-css gulp-uglify gulp-imagemin gulp-livereload gulp-cache del gulp-usemin run-sequence --save-dev</div></pre></td></tr></table></figure>
<h3 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h3><p>在根目录创建 <code>gulpfile.js</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;),</div><div class="line">    uglify = require(&apos;gulp-uglify&apos;),</div><div class="line">    minifyCss = require(&apos;gulp-minify-css&apos;),</div><div class="line">    del = require(&apos;del&apos;),</div><div class="line">    usemin = require(&apos;gulp-usemin&apos;),</div><div class="line">    imagemin = require(&apos;gulp-imagemin&apos;),</div><div class="line">    cache = require(&apos;gulp-cache&apos;),</div><div class="line">    rev = require(&apos;gulp-rev&apos;),</div><div class="line">    runSequence = require(&apos;run-sequence&apos;),</div><div class="line">    livereload = require(&apos;gulp-livereload&apos;);</div></pre></td></tr></table></figure></p>
<h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p><strong>先看一下 <a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="external">Gulp API</a></strong></p>
<p><strong>继续 code:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 压缩图片任务</div><div class="line">gulp.task(&apos;build-img&apos;, function() &#123;</div><div class="line">    return gulp.src(&apos;img/**/*.&#123;gif,jpeg,jpg,png&#125;&apos;)</div><div class="line">        .pipe(cache(imagemin(&#123;progressive: true&#125;)))</div><div class="line">        .pipe(gulp.dest(&apos;dist/img&apos;));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// deploy css</div><div class="line">gulp.task(&apos;deploy-css&apos;, function() &#123;</div><div class="line">    return gulp.src(&apos;dist/css/**/*.*&apos;)</div><div class="line">        .pipe(gulp.dest(&apos;../myapps/static/css/&apos;));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 清除目录</div><div class="line">gulp.task(&apos;clean&apos;, function(cb) &#123;</div><div class="line">    return del([&apos;.tmp&apos;, &apos;dist&apos;], cb);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 设置默认任务</div><div class="line">gulp.task(&apos;default&apos;, [&apos;clean&apos;], function() &#123;</div><div class="line">    // 依次执行任务</div><div class="line">    runSequence(&apos;task0&apos;, // task0 为任务名，比如上面的 build-img、clean</div><div class="line">                [&apos;task1-a&apos;, &apos;task1-b&apos;, &apos;task1-c&apos;],  // 并行执行的任务</div><div class="line">                &apos;task2&apos;,</div><div class="line">                function () &#123;</div><div class="line">                    // do sth after tasks done</div><div class="line">                &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// watch 任务</div><div class="line">gulp.task(&apos;watch&apos;, function() &#123;</div><div class="line">    // 监听</div><div class="line">    livereload.listen();</div><div class="line"></div><div class="line">    // 监听 img</div><div class="line">    gulp.watch(&apos;img/**/*.&#123;gif,jpeg,jpg,png&#125;&apos;, [&apos;build-img&apos;]);</div><div class="line"></div><div class="line">    // dist 目标有变动则执行系列任务后，自动刷新页面</div><div class="line">    gulp.watch(&apos;dist/**/*.*&apos;, function() &#123;</div><div class="line">        runSequence(&apos;deploy-css&apos;,</div><div class="line">                    &apos;deploy-img&apos;,</div><div class="line">                    ...,</div><div class="line">                    livereload.reload);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gulp</div><div class="line">// 等同于</div><div class="line">gulp default</div><div class="line"></div><div class="line">// 执行监听任务</div><div class="line">gulp watch</div></pre></td></tr></table></figure>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>更多详细内容请点击以上 gulp 及其插件链接。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【译】为什么Python中没有Switch/Case语句]]></title>
      <url>https://seven88.github.io/2015/09/05/%E3%80%90%E8%AF%91%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88Python%E4%B8%AD%E6%B2%A1%E6%9C%89Switch-Case%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<p><strong>英文出处：<a href="http://www.pydanny.com/why-doesnt-python-have-switch-case.html" target="_blank" rel="external">pydanny.com</a></strong><br><strong>校稿：<a href="http://www.jobbole.com/members/tangyouhua" target="_blank" rel="external">伯乐在线 - 唐尤华</a></strong></p>
<p>不同于我用过的其它编程语言，Python 没有 switch / case 语句。为了实现它，我们可以使用字典映射：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers_to_strings</span><span class="params">(argument)</span>:</span></div><div class="line">    switcher = &#123;</div><div class="line">        <span class="number">0</span>: <span class="string">"zero"</span>,</div><div class="line">        <span class="number">1</span>: <span class="string">"one"</span>,</div><div class="line">        <span class="number">2</span>: <span class="string">"two"</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> switcher.get(argument, <span class="string">"nothing"</span>)</div></pre></td></tr></table></figure>
<p>这段代码在 JavaScript 中相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">argument</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(argument) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">"zero"</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">"one"</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">"two"</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">"nothing"</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Python 代码通常比处理 case 的标准方法更为简短，也可以说它更难理解。当我初次使用 Python 时，感觉很奇怪并且心烦意乱。而随着时间的推移，在 switch 中使用字典的 key 来做标识符变得越来越习以为常。</p>
<a id="more"></a>
<h3 id="函数的字典映射"><a href="#函数的字典映射" class="headerlink" title="函数的字典映射"></a>函数的字典映射</h3><p>在 Python 中字典映射也可以包含函数或者 lambda 表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"zero"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">one</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"one"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers_to_functions_to_strings</span><span class="params">(argument)</span>:</span></div><div class="line">    switcher = &#123;</div><div class="line">        <span class="number">0</span>: zero,</div><div class="line">        <span class="number">1</span>: one,</div><div class="line">        <span class="number">2</span>: <span class="keyword">lambda</span>: <span class="string">"two"</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="comment"># Get the function from switcher dictionary</span></div><div class="line">    func = switcher.get(argument, <span class="keyword">lambda</span>: <span class="string">"nothing"</span>)</div><div class="line">    <span class="comment"># Execute the function</span></div><div class="line">    <span class="keyword">return</span> func()</div></pre></td></tr></table></figure>
<p>虽然 zero 和 one 中的代码很简单，但是很多 Python 程序使用这样的字典映射来调度复杂的流程。</p>
<h3 id="类的调度方法"><a href="#类的调度方法" class="headerlink" title="类的调度方法"></a>类的调度方法</h3><p>如果在一个类中，不确定要使用哪种方法，可以用一个调度方法在运行的时候来确定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numbers_to_methods_to_strings</span><span class="params">(self, argument)</span>:</span></div><div class="line">        <span class="string">"""Dispatch method"""</span></div><div class="line">        <span class="comment"># prefix the method_name with 'number_' because method names</span></div><div class="line">        <span class="comment"># cannot begin with an integer.</span></div><div class="line">        method_name = <span class="string">'number_'</span> + str(argument)</div><div class="line">        <span class="comment"># Get the method from 'self'. Default to a lambda.</span></div><div class="line">        method = getattr(self, method_name, <span class="keyword">lambda</span>: <span class="string">"nothing"</span>)</div><div class="line">        <span class="comment"># Call the method as we return it</span></div><div class="line">        <span class="keyword">return</span> method()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">number_0</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"zero"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">number_1</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"one"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">number_2</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"two"</span></div></pre></td></tr></table></figure>
<p>很灵活，对吧？</p>
<h3 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h3><p><a href="https://docs.python.org/2/faq/design.html#why-isn-t-there-a-switch-or-case-statement-in-python" target="_blank" rel="external">官方的解释</a>说，</p>
<blockquote>
<p>用<code>if... elif... elif... else</code>序列很容易来实现 switch / case 语句。</p>
</blockquote>
<p>而且可以使用函数字典映射和类的调度方法。</p>
<p>可以说官方的说明并没有解释什么，只是给出了解决方案。换句话说，没有回答为什么。我认为其实官方真正想说的是：“Python 不需要 switch / case 语句”。</p>
<h3 id="真的是这样吗？"><a href="#真的是这样吗？" class="headerlink" title="真的是这样吗？"></a>真的是这样吗？</h3><p>是的。但是还有别的原因。我听牛人说过，在代码中 switch/case 语句真的很难调试。</p>
<p>就我个人而言，我发现当运行到大量嵌套的用作代码分支映射的字典里，上述说法就站不住脚了。想想吧，一个超过100条语句的嵌套字典，和一个嵌套100个以上 case 的 switch/case 代码块一样，都是难以调试的。</p>
<h3 id="字典映射运行更快？"><a href="#字典映射运行更快？" class="headerlink" title="字典映射运行更快？"></a>字典映射运行更快？</h3><p>Python 没有 case 语句，使用其它语言的衡量标准是没有意义的，因为在某种语言中运行更快并不意味着在另一种语言中也一样。让我们继续。</p>
<h3 id="Python-实现方法的显著优点"><a href="#Python-实现方法的显著优点" class="headerlink" title="Python 实现方法的显著优点"></a>Python 实现方法的显著优点</h3><p>有时候我会遇到 Python 的实现方法比 switch/case 语句更好用的情况，例如在运行的时候，需要从映射里添加或者删除一些潜在的选项。每当这时，多年来使用字典映射和调度方法的实践让我受益匪浅。现在我觉得，我再也无法回到依赖 switch/case 语句的日子了。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Python 迫使我积累了很多映射的实践经验，对我来说是塞翁失马，焉知非福。没有 switch/case 语句可用的约束，促使我想到了可能不会用来开发的方法和主意。</p>
<p>有意或无意中，Python 没有 switch/case 语句已成为一种社会建构，并让我成为一个更优秀的程序员。</p>
<p>综上所述，所以我认为这种意外的社会构建解释比官方的“用这个来代替”的说明要好得多。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用 IPython 的 autoreload 自动重新加载]]></title>
      <url>https://seven88.github.io/2015/06/30/%E4%BD%BF%E7%94%A8-IPython-%E7%9A%84-autoreload-%E8%87%AA%E5%8A%A8%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p><a href="http://ipython.org/" target="_blank" rel="external">IPython</a> 是极好用的 Python 交互 shell。</p>
<p>先来看一个使用场景，运行 IPython：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> a.b imort c</div><div class="line">In [<span class="number">2</span>]: c()</div><div class="line">hello world  <span class="comment"># c 函数的功能 打印 hello world</span></div><div class="line"><span class="comment"># 这时修改了 c 函数，在 'hello world' 后面加一个 '!'</span></div><div class="line">In [<span class="number">3</span>]: c()</div><div class="line">hello world  <span class="comment"># 会发现并不是修改后的结果</span></div></pre></td></tr></table></figure>
<p>通常做法是重启 shell，重新 import，这样当然可以，但我们可以优雅的使用 IPython 的 autoreload 来处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> a.b imort c</div><div class="line">In [<span class="number">2</span>]: c()</div><div class="line">hello world  <span class="comment"># c 函数的功能 打印 hello world</span></div><div class="line"><span class="comment"># 这时修改了 c 函数，在 'hello world' 后面加一个 '!'</span></div><div class="line">In [<span class="number">3</span>]: %load_ext autoreload</div><div class="line">In [<span class="number">4</span>]: %autoreload <span class="number">2</span></div><div class="line">In [<span class="number">5</span>]: c()</div><div class="line">hello world!  <span class="comment"># 自动重新加载了</span></div></pre></td></tr></table></figure>
<p><code>%load_ext autoreload</code> + <code>%autoreload 2</code>，两步轻松实现自动加载，是不是很爽？</p>
<p>参考文档：<br><a href="http://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html" target="_blank" rel="external">http://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式入门及 Python 常见用法]]></title>
      <url>https://seven88.github.io/2015/03/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E5%8F%8A-Python-%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p>正则表达式是由字符和特殊符号组成的字符串，用来匹配符合某个句法规则的字符串。</p>
<h2 id="为什么要用正则表达式"><a href="#为什么要用正则表达式" class="headerlink" title="为什么要用正则表达式"></a>为什么要用正则表达式</h2><p>对于一些简单的字符串查找，可以使用字符串匹配方法来实现。比如检测一个字符串是否以 <code>&#39;abc&#39;</code> 开头，用 Python 中的字符串方法 <code>startswith</code> 即可。但对于一些复杂的规则，比如检测一个字符串是否是一个 email 地址，用字符串匹配检查等方法当然也能实现，但是会很麻烦，用正则表达式就简单很多。此外，在大数据处理、网页爬取等方面，正则表达式有着广泛的应用。</p>
<h2 id="正则表达式怎么写"><a href="#正则表达式怎么写" class="headerlink" title="正则表达式怎么写"></a>正则表达式怎么写</h2><p>首先来介绍组成正则表达式最常用的字符和符号，如下表：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>正则表达式示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>str</td>
<td>匹配字符串的值</td>
<td>hello</td>
</tr>
<tr>
<td>re1&#124;re2</td>
<td>匹配正则表达式 re1 或者 re2</td>
<td>hello&#124;hi</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符（换行符除外）</td>
<td>b.b</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
<td>^hello</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
<td>world$</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面出现的正则表达式零次或者多次</td>
<td>[a-z0-9]*</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面出现的正则表达式一次或者多次</td>
<td>[a-z]+\.com</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面出现的正则表达式零次或者一次</td>
<td>goo？</td>
</tr>
<tr>
<td>{N}</td>
<td>匹配前面出现的正则表达式 N 次</td>
<td>[a-z]{3}</td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配重复出现 M 到 N 次的正则表达式</td>
<td>[0-9]{3,5}</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配字符组里出现的任意一个字符。特殊字符仅有反斜线 \ 保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。</td>
<td>[aoe]</td>
</tr>
<tr>
<td>[..x-y..]</td>
<td>匹配从字符 x 到 y 中的任意一个字符</td>
<td>[A-Za-z], [0-9]</td>
</tr>
<tr>
<td>[^..]</td>
<td>不匹配此字符集中出现的任何一个字符，包括某一范围的字符</td>
<td>[^aoe], [^A-Za-z]</td>
</tr>
<tr>
<td>(…)</td>
<td>匹配封闭括号中正则表达式，并保存为子组</td>
<td>([0-9]{3})?, f(oo&#124;u)bar</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任意数字，和 [0-9] 一样 （\D 为反义，匹配非数字）</td>
<td>str\d</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任意数字、字母字符，和 [A-Za-z0-9_] 一样 （\W 为反义）</td>
<td>abc\w</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意空白符，和 [\n\r\t\v\f] 相同 （\S 为反义）</td>
<td>end\s</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置 \B 为反义）</td>
<td>hi\b</td>
</tr>
<tr>
<td>\nn</td>
<td>匹配已保存的子组</td>
<td>price:\16</td>
</tr>
<tr>
<td>\c</td>
<td>匹配特殊字符c</td>
<td>\., \\, \*</td>
</tr>
<tr>
<td>\A(\Z)</td>
<td>匹配字符串的起始（结束）</td>
<td>\ADear, End\Z</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="用管道符-匹配多个正则表达式模式"><a href="#用管道符-匹配多个正则表达式模式" class="headerlink" title="用管道符 | 匹配多个正则表达式模式"></a>用管道符 <code>|</code> 匹配多个正则表达式模式</h3><p>使用管道符可以灵活的匹配不止一个字符串。</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>here&#124;there</td>
<td>here, there</td>
</tr>
<tr>
<td>com&#124;cn</td>
<td>com, cn</td>
</tr>
<tr>
<td>bat&#124;bet&#124;bit</td>
<td>bat, bet, bit</td>
</tr>
</tbody>
</table>
<h3 id="匹配任意单一字符"><a href="#匹配任意单一字符" class="headerlink" title="匹配任意单一字符 ."></a>匹配任意单一字符 <code>.</code></h3><p>使用 <code>.</code> 符合，可以匹配除换行符外的任意一个字符。注意，匹配 <code>.</code> 本身，需用 <code>\.</code> 来转义。</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>f.c</td>
<td>f 和 c 之间可以是任意字符，如fac, f8c</td>
</tr>
<tr>
<td>..</td>
<td>任意两个字符</td>
</tr>
</tbody>
</table>
<h3 id="从字符结尾或者单词边界开始匹配-b-B"><a href="#从字符结尾或者单词边界开始匹配-b-B" class="headerlink" title="从字符结尾或者单词边界开始匹配 ^ $ \b \B"></a>从字符结尾或者单词边界开始匹配 <code>^ $ \b \B</code></h3><p>用 <code>^</code> 和 <code>$</code> 从字符串的开头或者结尾来匹配的情况：</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>^Hi</td>
<td>任意以 Hi 开头的字符串</td>
</tr>
<tr>
<td>bye$</td>
<td>任意以 bye 结尾的字符串</td>
</tr>
<tr>
<td>^Good luck$</td>
<td>仅匹配 <code>Good luck</code> 字符串</td>
</tr>
</tbody>
</table>
<p>使用 <code>\b</code> 和 <code>\B</code> 匹配单词边界的示例：</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>\bthe</td>
<td>以 the 开头的字符串</td>
</tr>
<tr>
<td>\bthe\b</td>
<td>仅匹配 the</td>
</tr>
<tr>
<td>\Bthe</td>
<td>任意保护 the 但不以 the 开头的单词，如 athe</td>
</tr>
</tbody>
</table>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类 []"></a>字符类 <code>[]</code></h3><p>匹配某些特定的字符，使用 <code>[]</code>。</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>b[aei]t</td>
<td>bat, bet, bit</td>
</tr>
<tr>
<td>[a-z]_[0-9]</td>
<td>首字符为小写字母，第二个字符是 <code>_</code>，第三个字符为数字的字符串</td>
</tr>
</tbody>
</table>
<h3 id="指定范围-和否定"><a href="#指定范围-和否定" class="headerlink" title="指定范围 - 和否定 ^"></a>指定范围 <code>-</code> 和否定 <code>^</code></h3><p>在方括号中使用 <code>-</code> 表示指定字符范围。方括号中第一个字符为 <code>^</code> 表示不匹配指定字符集里的任意字符。</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>x[0-9]</td>
<td>第一个字符为 <code>x</code>，第二个字符为任意数字</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>一个不为小写字母的字符</td>
</tr>
<tr>
<td>^\t\n</td>
<td>除 TAB 符和换行符外的任意一个字符</td>
</tr>
<tr>
<td>“-a</td>
<td>ASCII 码中按顺序从 <code>&quot;</code> 到 <code>a</code> 的任意一个字符</td>
</tr>
</tbody>
</table>
<h3 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h3><table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>0?[1-9]</td>
<td>1~9中任意数字，前面可能还有一个 0</td>
</tr>
<tr>
<td>&lt;/?[^&gt;]+&gt;</td>
<td>html 标签（没验证是否有效）</td>
</tr>
</tbody>
</table>
<p>[[0-9]{8,10} ] 8到10位数字 |</p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>前面提到的一些特殊字符可以表示字符集和，如 <code>\d</code> 表示 <code>0~9</code>。来看几组示例：</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>\w+\d+</td>
<td>一个由字母、数字或 <code>_</code> 组成的字符串，结尾是一个或多个数字</td>
</tr>
<tr>
<td>137\d{8}</td>
<td>137 开头的手机号码</td>
</tr>
<tr>
<td>^.+@[^.].*\.[a-z]{2,10}$</td>
<td>email 地址</td>
</tr>
</tbody>
</table>
<h3 id="用-建组"><a href="#用-建组" class="headerlink" title="用 () 建组"></a>用 <code>()</code> 建组</h3><p>有时候除了匹配检查字符串是否符合某个规则，还想再匹配成功时取出特定字符，就需要使用 <code>()</code> 来实现了。</p>
<p>圆括号在正则表达式中使用可以实现以下功能：</p>
<ul>
<li>对正则表达式进行分组</li>
<li>匹配子组</li>
</ul>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d+(\.\d*)?</td>
<td>表示简单的浮点型</td>
</tr>
<tr>
<td>(Mr?s?\.)?[A-z][a-z]* [ A-za-z-]+</td>
<td>英文名和姓</td>
</tr>
</tbody>
</table>
<h2 id="Python-中正则表达式常用方法"><a href="#Python-中正则表达式常用方法" class="headerlink" title="Python 中正则表达式常用方法"></a>Python 中正则表达式常用方法</h2><h3 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h3><p>Python 中使用正则表达式，需要用到 <code>re</code> 模块。下面介绍该模块常见的一些方法。</p>
<h3 id="re-match-pattern-string-flags-0"><a href="#re-match-pattern-string-flags-0" class="headerlink" title="re.match(pattern, string, flags=0)"></a>re.match(pattern, string, flags=0)</h3><p>用正则表达式 <code>pattern</code> 匹配字符串 <code>string</code>，<code>flags</code> 为可选标识符。<code>flags</code> 可选值为：</p>
<table>
<thead>
<tr>
<th>flags 值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.I</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>re.L</td>
<td>‘\w’, ‘\W’, ‘\b’, ‘\B’, ‘\s’, ‘\S’ 的使用与当前位置有关</td>
</tr>
<tr>
<td>re.M</td>
<td>使 ‘^’, ‘$’ 分别匹配字符串和行的开始和结束，如果不指定则只匹配字符串的</td>
</tr>
<tr>
<td>re.S</td>
<td>使 <code>.</code> 匹配任何东西，包括一个换行；如果不指定，则不匹配换行</td>
</tr>
<tr>
<td>re.U</td>
<td>使 ‘\w’, ‘\W’, ‘\b’, ‘\B’, ‘\d’, ‘\D’, ‘\s’, ‘\S’ 依赖于unicode字符属性数据库</td>
</tr>
<tr>
<td>re.X</td>
<td>使空格（除了转义字符代表的空格），和 <code>#</code> 不作为正则表达式的一部分，这样写出的正则表达式更加优美，还可以加 <code>#</code> 注释</td>
</tr>
</tbody>
</table>
<p><code>match</code> 方法会从<strong>字符串开头</strong>开始匹配，如果匹配成功，返回一个匹配对象，失败则返回 <code>None</code>。匹配对象可以使用 <code>group()</code> 方法来显示成功的匹配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">'a[a-z]'</span>, <span class="string">'abcd'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line"><span class="meta">... </span>    m.group()</div><div class="line"><span class="string">'ab'</span></div></pre></td></tr></table></figure>
<h3 id="re-search-pattern-string-flags-0"><a href="#re-search-pattern-string-flags-0" class="headerlink" title="re.search(pattern, string, flags=0)"></a>re.search(pattern, string, flags=0)</h3><p><code>search</code> 方法的参数和 <code>match</code> 相同，区别在于 <code>search</code> 会匹配字符串中任意位置。如果匹配成功，返回一个匹配对象，失败则返回 <code>None</code>。</p>
<p>来看两个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">'f[oae]+'</span>, <span class="string">'somefoo'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line"><span class="meta">... </span>    m.group()</div><div class="line"><span class="string">'foo'</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">'f[oae]+'</span>, <span class="string">'somefoo'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:   <span class="comment"># 此时 m 为 None</span></div><div class="line"><span class="meta">... </span>    m.group()</div></pre></td></tr></table></figure>
<h3 id="子组的使用"><a href="#子组的使用" class="headerlink" title="子组的使用"></a>子组的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">'(\w\w\w)-(\d\d\d)'</span>, <span class="string">'abc-123'</span>)  <span class="comment"># 用 () 进行了分组</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line"><span class="meta">... </span>    m.group()   <span class="comment"># 所有匹配的部分</span></div><div class="line"><span class="string">'abc-123'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)  <span class="comment"># 匹配的子组1</span></div><div class="line"><span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)  <span class="comment"># 匹配的子组2</span></div><div class="line"><span class="string">'123'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()  <span class="comment"># 匹配的所有子组</span></div><div class="line">(<span class="string">'abc'</span>, <span class="string">'123'</span>)</div></pre></td></tr></table></figure>
<p>当有匹配分组时，可以使用 <code>groups</code> 方法获取一个包含所有匹配子组的元组。</p>
<p>子组还可以嵌套使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">'(a(b))'</span>, <span class="string">'ab'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()</div><div class="line"><span class="string">'ab'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</div><div class="line"><span class="string">'ab'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</div><div class="line"><span class="string">'b'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</div><div class="line">(<span class="string">'ab'</span>, <span class="string">'b'</span>)</div></pre></td></tr></table></figure>
<h3 id="re-findall-pattern-string-flags-0"><a href="#re-findall-pattern-string-flags-0" class="headerlink" title="re.findall(pattern, string, flags=0)"></a>re.findall(pattern, string, flags=0)</h3><p>参数同 <code>search</code>。<code>findall</code> 返回所有匹配成功的列表，如无匹配，返回空列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">'er'</span>, <span class="string">'there is peter'</span>)</div><div class="line">[<span class="string">'er'</span>, <span class="string">'er'</span>]</div></pre></td></tr></table></figure>
<h3 id="re-sub-pattern-repl-string-count-0-flags-0"><a href="#re-sub-pattern-repl-string-count-0-flags-0" class="headerlink" title="re.sub(pattern, repl, string, count=0, flags=0)"></a>re.sub(pattern, repl, string, count=0, flags=0)</h3><p>用正则表达式 <code>pattern</code> 匹配字符串 <code>string</code>，匹配成功后用 <code>repl</code> 进行替换。<code>count</code> 为最大替换次数，0 表示全部替换。<code>flags</code> 为可选标识符。返回替换后的字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">'X'</span>, <span class="string">'10'</span>, <span class="string">'X * X == X ** 2'</span>)</div><div class="line"><span class="string">'10 * 10 == 10 ** 2'</span></div></pre></td></tr></table></figure>
<p>另外还有一个 <code>re.subn</code> 方法，参数和 <code>sub</code> 相同，返回值不同，为一个元组：(‘替换后的字符串’, 替换的次数)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.subn(<span class="string">'X'</span>, <span class="string">'10'</span>, <span class="string">'X * X == X ** 2'</span>)</div><div class="line">(<span class="string">'10 * 10 == 10 ** 2'</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<h3 id="re-split-pattern-string-maxsplit-0-flags-0"><a href="#re-split-pattern-string-maxsplit-0-flags-0" class="headerlink" title="re.split(pattern, string, maxsplit=0, flags=0)"></a>re.split(pattern, string, maxsplit=0, flags=0)</h3><p>用正则表达式 <code>pattern</code> 分割 <code>string</code>，<code>maxsplit</code> 为最大分隔次数，0 表示全部分隔。<code>flags</code> 为可选标识符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">'\W+'</span>, <span class="string">'Words, words, words.'</span>)  <span class="comment"># 用非数字字母分割</span></div><div class="line">[<span class="string">'Words'</span>, <span class="string">'words'</span>, <span class="string">'words'</span>, <span class="string">''</span>]</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python 修改 pip 镜像源]]></title>
      <url>https://seven88.github.io/2015/02/09/Python-%E4%BF%AE%E6%94%B9-pip-%E9%95%9C%E5%83%8F%E6%BA%90/</url>
      <content type="html"><![CDATA[<p>使用 Python 的童鞋免不了需要 <code>pip</code> 来安装第三方依赖。但由于官方源在国外，下载很慢或者直接连接不上的情况时有发生。所以使用一个靠谱的镜像源就很有必要了。</p>
<p>这里推荐使用豆瓣的镜像源，<a href="https://pypi.doubanio.com/simple/" target="_blank" rel="external">https://pypi.doubanio.com/simple/</a>。</p>
<h3 id="还没有安装-pip？"><a href="#还没有安装-pip？" class="headerlink" title="还没有安装 pip？"></a>还没有安装 pip？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 下载安装文件</span></div><div class="line">wget https://bootstrap.pypa.io/get-pip.py</div><div class="line"><span class="comment"># 执行安装</span></div><div class="line">sudo python get-pip.py</div></pre></td></tr></table></figure>
<h3 id="pip-源修改"><a href="#pip-源修改" class="headerlink" title="pip 源修改"></a>pip 源修改</h3><p>修改源十分简单，只需配置用户目录下的 <code>.pip/pip.conf</code> 文件即可。步骤如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~</div><div class="line">mkdir .pip</div><div class="line"><span class="built_in">cd</span> .pip</div><div class="line">touch pip.conf</div></pre></td></tr></table></figure>
<p>接着在 <code>pip.conf</code> 写入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url = https://pypi.doubanio.com/simple/</div></pre></td></tr></table></figure>
<p>之后使用 <code>pip</code> 命令就会直接从指定的源安装了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 虚拟环境 virtualenv 的使用]]></title>
      <url>https://seven88.github.io/2015/01/29/python-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83-virtualenv-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="什么是-virtualenv？"><a href="#什么是-virtualenv？" class="headerlink" title="什么是 virtualenv？"></a>什么是 virtualenv？</h2><p>官方说明：</p>
<blockquote>
<p>virtualenv is a tool to create isolated Python environments.</p>
</blockquote>
<h2 id="为什么要用虚拟环境？"><a href="#为什么要用虚拟环境？" class="headerlink" title="为什么要用虚拟环境？"></a>为什么要用虚拟环境？</h2><p>Python 开发环境中，经常会有库依赖、版本以及系统权限等问题，比如不同项目使用的 Django 版本不同，如果直接使用系统环境，项目将无法同时运行。使用虚拟环境就可以解决这个问题。</p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>使用 <code>pip</code> 安装即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenv</div></pre></td></tr></table></figure>
<p>具体可参考<a href="https://pip.pypa.io/en/latest/installing.html" target="_blank" rel="external">官方文档</a> 。</p>
<p>本文推荐另一个更为好用的工具 <code>virtualenvwrapper</code>，它对 <code>virtualenv</code> 进行了一些非常方便使用的包装。</p>
<a id="more"></a>
<p>使用 <code>pip</code> 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenvwrapper</div></pre></td></tr></table></figure>
<p>安装后即可使用了，常用命令如下：</p>
<h3 id="mkvirtualenv"><a href="#mkvirtualenv" class="headerlink" title="mkvirtualenv"></a>mkvirtualenv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkvirtualenv envname</div></pre></td></tr></table></figure>
<p>创建一个名为 envname 的虚拟环境，并自动切换到该环境。</p>
<p>创建后的环境已自动安装 <code>pip</code>，之后在环境中可直接安装需要的依赖，如 <code>pip install flask</code>。</p>
<h3 id="workon"><a href="#workon" class="headerlink" title="workon"></a>workon</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">workon envname</div></pre></td></tr></table></figure>
<p>切换到名为 envname 的虚拟环境。</p>
<h3 id="deactivate"><a href="#deactivate" class="headerlink" title="deactivate"></a>deactivate</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deactivate</div></pre></td></tr></table></figure>
<p>退出当前虚拟环境，使用系统环境。</p>
<h3 id="setvirtualenvproject"><a href="#setvirtualenvproject" class="headerlink" title="setvirtualenvproject"></a>setvirtualenvproject</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setvirtualenvproject</div></pre></td></tr></table></figure>
<p>指定所在目录为当前虚拟环境的默认目录，当下次切换到该环境中，自动进入该目录。</p>
<h3 id="rmvirtualenv"><a href="#rmvirtualenv" class="headerlink" title="rmvirtualenv"></a>rmvirtualenv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rmvirtualenv envname</div></pre></td></tr></table></figure>
<p>删除名为 envname 的虚拟环境。</p>
]]></content>
    </entry>
    
  
  
</search>
